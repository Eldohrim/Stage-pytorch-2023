<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.427">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Rapport stage d’été 2023</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="rapport_files/libs/clipboard/clipboard.min.js"></script>
<script src="rapport_files/libs/quarto-html/quarto.js"></script>
<script src="rapport_files/libs/quarto-html/popper.min.js"></script>
<script src="rapport_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="rapport_files/libs/quarto-html/anchor.min.js"></script>
<link href="rapport_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="rapport_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="rapport_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="rapport_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="rapport_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sommaire</h2>
   
  <ul class="collapse">
  <li><a href="#explication-de-larticle-who-said-what-guan2018said" id="toc-explication-de-larticle-who-said-what-guan2018said" class="nav-link active" data-scroll-target="#explication-de-larticle-who-said-what-guan2018said"><span class="header-section-number">1</span> Explication de l’article Who Said What <span class="citation" data-cites="guan2018said">(Guan et al. 2018)</span></a></li>
  <li><a href="#implémentation-avec-peerannot" id="toc-implémentation-avec-peerannot" class="nav-link" data-scroll-target="#implémentation-avec-peerannot"><span class="header-section-number">2</span> Implémentation avec Peerannot</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="..\rapport.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Rapport stage d’été 2023</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>&nbsp; &nbsp; Voici le rapport du stage effectué en Juin et Juillet 2023 à l’Institut Montpelliérain Alexander Grothendieck. Ce dernier va se découper en deux grosses parties :</p>
<ul>
<li>la première visant à rappeler et expliqué un article de crowdsourcing <span class="citation" data-cites="guan2018said">(<a href="#ref-guan2018said" role="doc-biblioref">Guan et al. 2018</a>)</span>.</li>
<li>la seconde portera plus sur l’implémentation de la méthode de l’article à l’aide du package <a href="https://peerannot.github.io/">Peerannot</a>.</li>
</ul>
<section id="explication-de-larticle-who-said-what-guan2018said" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="explication-de-larticle-who-said-what-guan2018said"><span class="header-section-number">1</span> Explication de l’article Who Said What <span class="citation" data-cites="guan2018said">(<a href="#ref-guan2018said" role="doc-biblioref">Guan et al. 2018</a>)</span></h2>
<section id="mise-en-contexte" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="mise-en-contexte"><span class="header-section-number">1.1</span> Mise en contexte</h3>
<p>&nbsp; &nbsp; Il arrive souvent qu’une donnée ne soit pas perçue de la même manière d’un travailleur à l’autre. Cela peut dépendre de plusieurs paramètres comme par exemple :</p>
<ul>
<li>l’expérience des travailleurs et leur fiabilité</li>
<li>la qualité des données : nombre de pixels dans une image par exemple.</li>
</ul>
<p>Dans le dataset CIFAR10H, où chaque image appartient à un ensemble de 10 classes disjointes, il peut arriver qu’il nous soit difficile de choisir entre deux classes.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="image_cifar10h.png" class="img-fluid figure-img" width="200"></p>
<figcaption class="figure-caption">Figure 1</figcaption>
</figure>
</div>
<p>Un cas concret où la labélisation d’une image n’est pas évidente, c’est lorsque l’on doit effectuer un diagnositic médical. Dans <span class="citation" data-cites="guan2018said">(<a href="#ref-guan2018said" role="doc-biblioref">Guan et al. 2018</a>)</span>, on se place dans un cadre un groupe de médecins étiquettent des dépistages de la rétinopathie diabétique (diabetic retinopathy, DR) en cinq classes différentes :</p>
<ul>
<li>Pas de DR</li>
<li>DR bénin (non proliférative)</li>
<li>DR moyen</li>
<li>DR sévère</li>
<li>DR proliferative</li>
</ul>
<p>IMAGE DES DIFFERENTES CLASSES</p>
<p>Chaque image sera traité par une petite partie de ce groupe de médecin (aléatoirement) et chaque médecin va étudier une petite partie de l’ensemble des dépistages.</p>
<p>On peut facilement se persuader ici que chaque expert va donner son propre diagnostic (éventuellement différents les uns des autres) du fait du potentiel bruit qui se trouve dans ces images.</p>
<p>C’est dans ce cadre que <span class="citation" data-cites="guan2018said">(<a href="#ref-guan2018said" role="doc-biblioref">Guan et al. 2018</a>)</span> va chercher à trouver un “véritable” diagnostic, que l’on utilisera ensuite pour entraîner notre modèle.</p>
</section>
<section id="modèle-de-crowdsourcing" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="modèle-de-crowdsourcing"><span class="header-section-number">1.2</span> Modèle de crowdsourcing</h3>
<p>&nbsp; &nbsp; Pour répondre à la problématique, [WsW] ont d’abord fixé leur modèle. Dans le cadre des médecins, ils vont modéliser chacun d’eux avec la base d’Inception-v3 qu’ils vont ensuite entraîner avec les opinions du médecin qu’il modélise. Par exemple, si le dataset comporte un jeu de données où le total des médecins ayant étiqueté au moins une image est de 31, nous devrons entraîner 31 modèles.</p>
<p>On voit assez rapidement, qu’en fonction du nombre d’expert du jeu de données, la mise en place du modèle sera plus au moins longue… De plus, on peut potentiellement être confronté à un nombre de donnée trop bas pour certains médecins. Ces contraintes sont à prendre en compte dans un tel modèle.</p>
</section>
<section id="exemples-de-statégie-pour-fusionner-les-opinions" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="exemples-de-statégie-pour-fusionner-les-opinions"><span class="header-section-number">1.3</span> Exemples de statégie pour fusionner les opinions</h3>
<p>&nbsp; &nbsp; Une fois que nous possèdons tout ces médecins modélisés, il va falloir réunir l’ensemble de leur opinion pour pouvoir en proposer une globale pour le modèle général et étiqueter de nouvelles données. Il y a des manières très intuitives que nous allons exposer ici.</p>
<p>On se place dans le cas où il y a N experts et C classes. On notera <span class="math inline">p_j(c)</span> la prédiction de la classe <span class="math inline">c</span> du modèle représentant l’expert <span class="math inline">j</span>.</p>
<section id="le-vote-majoritaire" class="level4" data-number="1.3.1">
<h4 data-number="1.3.1" class="anchored" data-anchor-id="le-vote-majoritaire"><span class="header-section-number">1.3.1</span> <strong>Le vote majoritaire</strong></h4>
<p>&nbsp; &nbsp; Ce cadre là est assez explicite. L’idée est d’organiser un vote des experts et sélectionner la classe ayant le plus de voix. Mathématiquement, si on note <span class="math inline">\hat{p}_j =\underset{c \in \llbracket 1,C \rrbracket}{\text{argmax}}~(p_j(c))</span>, alors la prédiction du modèle sera : <span class="math display">
\hat{Y}_c =  \frac{1}{N}\sum_{j=1}^{N} \mathbb{1}_{\hat{p}_j=c}
</span></p>
<p>Ici, la classe ayant la probabilité la plus haute sera celle ayant reçu le plus de voix.</p>
</section>
<section id="lexpert-moyen" class="level4" data-number="1.3.2">
<h4 data-number="1.3.2" class="anchored" data-anchor-id="lexpert-moyen"><span class="header-section-number">1.3.2</span> <strong>L’expert moyen</strong></h4>
<p>&nbsp; &nbsp; Ce paradigme est sûrement le plus simple et évident de la liste. Il consiste à utiliser les prédictions de chaque expert et de faire une moyenne en utilisant un poids uniforme pour chaque expert. On peut le calculer :</p>
<p><span class="math display">
Y_c = \frac{1}{N}\sum_{j=1}^{N}p_j(c)
</span></p>
<p>Il modélise ce qu’est censé dire un expert “moyen” (par rapport à l’ensemble des experts du modèle).</p>
</section>
<section id="pondérer-en-fonction-de-la-fiabilité" class="level4" data-number="1.3.3">
<h4 data-number="1.3.3" class="anchored" data-anchor-id="pondérer-en-fonction-de-la-fiabilité"><span class="header-section-number">1.3.3</span> <strong>Pondérer en fonction de la fiabilité</strong></h4>
</section>
</section>
<section id="méthode-de-wsw" class="level3" data-number="1.4">
<h3 data-number="1.4" class="anchored" data-anchor-id="méthode-de-wsw"><span class="header-section-number">1.4</span> Méthode de [WsW]</h3>
</section>
<section id="pourquoi-les-erreurs-des-experts-ne-posent-pas-de-problème" class="level3" data-number="1.5">
<h3 data-number="1.5" class="anchored" data-anchor-id="pourquoi-les-erreurs-des-experts-ne-posent-pas-de-problème"><span class="header-section-number">1.5</span> Pourquoi les erreurs des experts ne posent pas de problème</h3>
</section>
</section>
<section id="implémentation-avec-peerannot" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="implémentation-avec-peerannot"><span class="header-section-number">2</span> Implémentation avec Peerannot</h2>
<p>PARLER DU PROBLEME AVEC LE BATCH FINAL QUI VAUT 1 (avec BN1 ça marche pas)</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-guan2018said" class="csl-entry" role="listitem">
Guan, Melody Y., Varun Gulshan, Andrew M. Dai, and Geoffrey E. Hinton. 2018. <span>“Who Said What: Modeling Individual Labelers Improves Classification.”</span> <a href="https://arxiv.org/abs/1703.08774">https://arxiv.org/abs/1703.08774</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>